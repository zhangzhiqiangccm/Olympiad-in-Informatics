f[len][mod] 表示长度为len的01串作为十进制数%n的余数为mod 
            此时最高位的1所在的位置

在当前01串前加上一位即可枚举出长度为len+1的01串的情况
如果最高位为0，则f[len+1][mod]=f[len][mod]//最高位1为原最高位1
如果最高位为1，则f[len+1][mod1]=len+1//最高位1为当前1
//mod1=(mod+10^len)%n 其中10^len需要分步求

因为要求最小正整数 因此先考虑最高位为0转移 不能转移则考虑最高位为1

pre[len+1][mod] 记录是由f[len]层的哪个余数转移过来的


在输出答案的时候，发现在2*10^4左右 乘数和结果都超出longlong型
因此需要通过pre型构造数字输出答案

关于结果：fen[i][mod]=i的时候表示当前位为1 反之为0 从高位到低位正常输出

关于乘数：模拟除法 输出每位的结果 注意前导0